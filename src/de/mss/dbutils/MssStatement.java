package de.mss.dbutils;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.mss.utils.StopWatch;
import de.mss.utils.Tools;


public class MssStatement implements Statement {

   protected String     loggingId       = null;
   protected String     sqlStatement    = null;
   protected String     sqlLogging      = null;
   protected Connection connection      = null;
   protected Statement  statement       = null;
   protected Throwable  logThrowable    = new Throwable();
   protected int        resultSetNumber = 0;


   private static Logger rootLogger = LogManager.getRootLogger();

   private Logger        logger     = rootLogger;


   public Logger getLogger() {
      if (this.logger == null)
         this.logger = rootLogger;

      return this.logger;
   }


   public void setLogger(Logger l) {
      this.logger = l;
   }


   public MssStatement(String logId, Logger ln, Connection con, Throwable t) {
      this.loggingId = logId;
      setLogger(ln);
      this.connection = con;
      this.logThrowable = t;
   }


   public MssStatement(String logId, Logger ln, Statement stmt, Throwable t) throws SQLException {
      this.loggingId = logId;
      setLogger(ln);
      this.statement = stmt;
      this.connection = stmt.getConnection();
      this.logThrowable = t;
   }


   @Override
   public <T> T unwrap(Class<T> iface) throws SQLException {
      return this.statement.unwrap(iface);
   }


   @Override
   public boolean isWrapperFor(Class<?> iface) throws SQLException {
      return this.statement.isWrapperFor(iface);
   }


   @Override
   public boolean execute(String sql) throws SQLException {
      try {
         this.sqlStatement = sql;
         this.sqlLogging = sql;
         return log(sql, new StopWatch(), this.statement.execute(sql));
      }
      catch (SQLException se) {
         log(sql, se);
         throw se;
      }
   }


   @Override
   public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
      try {
         this.sqlStatement = sql;
         this.sqlLogging = sql;
         return log(sql, new StopWatch(), this.statement.execute(sql, autoGeneratedKeys));
      }
      catch (SQLException se) {
         log(sql, se);
         throw se;
      }
   }


   @Override
   public boolean execute(String sql, int[] columnIndexes) throws SQLException {
      try {
         this.sqlStatement = sql;
         this.sqlLogging = sql;
         return log(sql, new StopWatch(), this.statement.execute(sql, columnIndexes));
      }
      catch (SQLException se) {
         log(sql, se);
         throw se;
      }
   }


   @Override
   public boolean execute(String sql, String[] columnNames) throws SQLException {
      try {
         this.sqlStatement = sql;
         this.sqlLogging = sql;
         return log(sql, new StopWatch(), this.statement.execute(sql, columnNames));
      }
      catch (SQLException se) {
         log(sql, se);
         throw se;
      }
   }


   @Override
   public ResultSet executeQuery(String sql) throws SQLException {
      try {
         this.sqlStatement = sql;
         this.sqlLogging = sql;
         return new MssResultSet(getLogger(), this.loggingId, log(sql, new StopWatch(), this.statement.executeQuery(sql)));
      }
      catch (SQLException se) {
         log(sql, se);
         throw se;
      }
   }


   @Override
   public int executeUpdate(String sql) throws SQLException {
      try {
         this.sqlStatement = sql;
         this.sqlLogging = sql;
         return log(sql, new StopWatch(), this.statement.executeUpdate(sql));
      }
      catch (SQLException se) {
         log(sql, se);
         throw se;
      }
   }


   @Override
   public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
      try {
         this.sqlStatement = sql;
         this.sqlLogging = sql;
         return log(sql, new StopWatch(), this.statement.executeUpdate(sql, autoGeneratedKeys));
      }
      catch (SQLException se) {
         log(sql, se);
         throw se;
      }
   }


   @Override
   public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
      try {
         this.sqlStatement = sql;
         this.sqlLogging = sql;
         return log(sql, new StopWatch(), this.statement.executeUpdate(sql, columnIndexes));
      }
      catch (SQLException se) {
         log(sql, se);
         throw se;
      }
   }


   @Override
   public int executeUpdate(String sql, String[] columnNames) throws SQLException {
      try {
         this.sqlStatement = sql;
         this.sqlLogging = sql;
         return log(sql, new StopWatch(), this.statement.executeUpdate(sql, columnNames));
      }
      catch (SQLException se) {
         log(sql, se);
         throw se;
      }
   }


   @Override
   public void close() throws SQLException {
      this.statement.close();
   }


   @Override
   public int getMaxFieldSize() throws SQLException {
      return this.statement.getMaxFieldSize();
   }


   @Override
   public void setMaxFieldSize(int max) throws SQLException {
      this.statement.setMaxFieldSize(max);
   }


   @Override
   public int getMaxRows() throws SQLException {
      return this.statement.getMaxRows();
   }


   @Override
   public void setMaxRows(int max) throws SQLException {
      this.statement.setMaxRows(max);
   }


   @Override
   public void setEscapeProcessing(boolean enable) throws SQLException {
      this.statement.setEscapeProcessing(enable);
   }


   @Override
   public int getQueryTimeout() throws SQLException {
      return this.statement.getQueryTimeout();
   }


   @Override
   public void setQueryTimeout(int seconds) throws SQLException {
      this.statement.setQueryTimeout(seconds);
   }


   @Override
   public void cancel() throws SQLException {
      this.statement.cancel();
   }


   @Override
   public SQLWarning getWarnings() throws SQLException {
      return this.statement.getWarnings();
   }


   @Override
   public void clearWarnings() throws SQLException {
      this.statement.clearWarnings();
   }


   @Override
   public void setCursorName(String name) throws SQLException {
      this.statement.setCursorName(name);
   }


   @Override
   public ResultSet getResultSet() throws SQLException {
      return new MssResultSet(getLogger(), this.loggingId, this.statement.getResultSet());
   }


   @Override
   public int getUpdateCount() throws SQLException {
      return this.statement.getUpdateCount();
   }


   @Override
   public boolean getMoreResults() throws SQLException {
      return this.statement.getMoreResults();
   }


   @Override
   public void setFetchDirection(int direction) throws SQLException {
      this.statement.setFetchDirection(direction);
   }


   @Override
   public int getFetchDirection() throws SQLException {
      return this.statement.getFetchDirection();
   }


   @Override
   public void setFetchSize(int rows) throws SQLException {
      this.statement.setFetchSize(rows);
   }


   @Override
   public int getFetchSize() throws SQLException {
      return this.statement.getFetchSize();
   }


   @Override
   public int getResultSetConcurrency() throws SQLException {
      return this.statement.getResultSetConcurrency();
   }


   @Override
   public int getResultSetType() throws SQLException {
      return this.statement.getResultSetType();
   }


   @Override
   public void addBatch(String sql) throws SQLException {
      this.statement.addBatch(sql);
   }


   @Override
   public void clearBatch() throws SQLException {
      this.statement.clearBatch();
   }


   @Override
   public int[] executeBatch() throws SQLException {
      return this.statement.executeBatch();
   }


   @Override
   public Connection getConnection() throws SQLException {
      return this.statement.getConnection();
   }


   @Override
   public boolean getMoreResults(int current) throws SQLException {
      return this.statement.getMoreResults(current);
   }


   @Override
   public ResultSet getGeneratedKeys() throws SQLException {
      return this.statement.getGeneratedKeys();
   }


   @Override
   public int getResultSetHoldability() throws SQLException {
      return this.statement.getResultSetHoldability();
   }


   @Override
   public boolean isClosed() throws SQLException {
      return this.statement.isClosed();
   }


   @Override
   public void setPoolable(boolean poolable) throws SQLException {
      this.statement.setPoolable(poolable);
   }


   @Override
   public boolean isPoolable() throws SQLException {
      return this.statement.isPoolable();
   }


   @Override
   public void closeOnCompletion() throws SQLException {
      this.statement.closeOnCompletion();
   }


   @Override
   public boolean isCloseOnCompletion() throws SQLException {
      return this.statement.isCloseOnCompletion();
   }


   protected void log(String sql, SQLException se) {
      getLogger().error(Tools.formatLoggingId(this.loggingId) + "error while executing [" + sql + "]", se);
   }


   protected ResultSet log(String sql, StopWatch sw, ResultSet resultSet) {
      getLogger().debug(Tools.formatLoggingId(this.loggingId) + "executing sql [" + sql + "] took " + sw.getDuration() + "ms");
      return resultSet;
   }


   protected int log(String sql, StopWatch sw, int rowCount) {
      getLogger().debug(Tools.formatLoggingId(this.loggingId) + "executing sql [" + sql + "] took " + sw.getDuration() + "ms");
      return rowCount;
   }


   protected boolean log(String sql, StopWatch sw, boolean ok) {
      getLogger().debug(Tools.formatLoggingId(this.loggingId) + "executing sql [" + sql + "] took " + sw.getDuration() + "ms");
      return ok;
   }


   public Statement getStatement() {
      return this.statement;
   }
}
